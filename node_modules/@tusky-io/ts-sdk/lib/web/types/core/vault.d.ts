import { Vault, VaultCreateOptions } from "../types/vault";
import { ListOptions, VaultGetOptions } from "../types/query-options";
import { Paginated } from "../types/paginated";
import { VaultService } from "./service/vault";
import { ServiceConfig } from ".";
import { Membership, MembershipAirdropOptions, RoleType, VaultUpdateOptions } from "../types";
declare class VaultModule {
    protected service: VaultService;
    constructor(config?: ServiceConfig);
    protected defaultListOptions: ListOptions;
    protected defaultGetOptions: VaultGetOptions;
    protected defaultCreateOptions: VaultCreateOptions;
    /**
     * @param {string} vaultId
     * @returns Promise with the decrypted vault
     */
    get(vaultId: string, options?: VaultGetOptions): Promise<Vault>;
    /**
     * @param {ListOptions} options
     * @returns Promise with paginated user vaults
     */
    list(options?: ListOptions): Promise<Paginated<Vault>>;
    /**
     * @param {ListOptions} options
     * @returns Promise with currently authenticated user vaults
     */
    listAll(options?: ListOptions): Promise<Array<Vault>>;
    /**
     * @param {string} name new vault name
     * @param {VaultCreateOptions} options public/private, description, tags, etc.
     * @returns {Promise<Vault>} Promise with newly created vault
     */
    create(name: string, options?: VaultCreateOptions): Promise<Vault>;
    /**
     * @param id vault id
     * @param name new vault name
     * @returns Promise with vault object
     */
    rename(id: string, name: string): Promise<Vault>;
    /**
     * Update vault metadata: name, description, tags
     * @param id vault id
     * @param updates vault metadata updates
     * @returns Promise with vault object
     */
    update(id: string, updates: VaultUpdateOptions): Promise<Vault>;
    /**
     * Delete the vault\
     * This action must be performed only for vault with no contents, it will fail if the vault is not empty.
     * @param id vault id
     * @returns {Promise<void>}
     */
    delete(id: string): Promise<void>;
    /**
     * Airdrop access to the vault directly through public keys
     * @param {string} vaultId
     * @param {MembershipAirdropOptions} options airdrop options
     * @returns {Promsise<Membership>} Promise with new membership
     */
    airdropAccess(vaultId: string, options?: MembershipAirdropOptions): Promise<{
        identityPrivateKey: string;
        password: string;
        membership: Membership;
    }>;
    /**
     * Revoke member access\
     * If private vault, vault keys will be rotated & distributed to all valid members
     * @param  {string} id membership id
     * @returns {Promise<void>}
     */
    revokeAccess(id: string): Promise<void>;
    /**
     * @param  {string} id membership id
     * @param  {RoleType} role VIEWER/CONTRIBUTOR/OWNER
     * @returns {Promise<Membership>}
     */
    changeAccess(id: string, role: RoleType): Promise<Membership>;
    /**
     * Retrieve all vault members
     * @param  {string} vaultId
     * @returns {Promise<Array<Membership>>}
     */
    members(vaultId: string): Promise<Array<Membership>>;
}
export { VaultModule };
