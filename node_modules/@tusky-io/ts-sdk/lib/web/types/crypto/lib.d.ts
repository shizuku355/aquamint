import { KeyPair } from "libsodium-wrappers";
import jsSHA from "jssha";
import { AESEncryptedPayload, X25519EncryptedPayload } from "./types";
import { ReadableStream } from "web-streams-polyfill/ponyfill";
export declare const KEY_DERIVATION_ITERATION_COUNT = 1000000;
export declare const AUTH_TAG_LENGTH_IN_BYTES = 16;
export declare const IV_LENGTH_IN_BYTES = 12;
/**
 * Export CryptoKey object to base64 encoded string
 * @param {CryptoKey} key
 * @returns {Promise.<string>} string containing crypto key
 */
declare function exportKeyToBase64(key: CryptoKey): Promise<string>;
/**
 * Export CryptoKey object to buffer key material
 * @param {CryptoKey} key
 * @returns {Promise.<Uint8Array>} buffer containing crypto key
 */
declare function exportKeyToArray(key: CryptoKey): Promise<Uint8Array>;
/**
 * Import CryptoKey object from base64 encoded string
 * @param {string} keyBase64
 * @returns {Promise.<CryptoKey>} crypto key object
 */
declare function importKeyFromBase64(keyBase64: string, extractable?: boolean): Promise<CryptoKey>;
/**
 * Import CryptoKey object from key buffer material
 * @param {Uint8Array} keyBuffer
 * @returns {Promise.<CryptoKey>} crypto key object
 */
declare function importKeyFromArray(keyBuffer: Uint8Array, extractable?: boolean): Promise<CryptoKey>;
/**
 * Import key from a random seed
 * @param {Uint8Array} seed
 * @returns {Promise.<CryptoKey>} crypto key object
 */
declare function importKeyFromSeed(seed: Uint8Array): Promise<CryptoKey>;
/**
 * Signature generation using sodium library: https://github.com/jedisct1/libsodium
 * @param {BufferSource} msgHash buffer message hash to be signed
 * @param {Uint8Array} privateKey private key used to sign message hash
 * @returns {Promise.<string>} signature as base64 string
 */
declare function signHash(msgHash: ArrayBuffer, privateKey: Uint8Array): Promise<string>;
/**
 * Digest generation
 * @param {string} payload string payload to be signed
 * @returns {Promise.<string>} payload digest as base64 string
 */
declare function digest(payload: string): Promise<string>;
declare function digestRaw(payload: Uint8Array): Promise<string>;
declare function initDigest(): jsSHA;
declare function chainDigest(digestObject: jsSHA, payload: Uint8Array): jsSHA;
/**
 * Signature generation
 * @param {string} payload string payload to be signed
 * @param {Uint8Array} privateKey private key used to sign string payload
 * @returns {Promise.<string>} signature as base64 string
 */
declare function signString(payload: string, privateKey: Uint8Array): Promise<string>;
/**
 * Encryption using WebCrypto
 * - generate a random initialization vector (iv)
 * - encrypt plaintext using key and iv
 * @param {Uint8Array} plaintext
 * @param {CryptoKey} key
 * @returns {Promise.<string>} Promise of base64 string represents the ciphertext along with iv
 */
declare function encryptAes(plaintext: Uint8Array, key: CryptoKey, encode?: boolean): Promise<string | Uint8Array>;
/**
 * Decryption using WebCrypto
 * - decrypt ciphertext using key and iv
 * @param {Object} encryptedPayload
 * @param {CryptoKey} key
 * @returns {Promise.<ArrayBuffer>} Promise of ArrayBuffer represents the plaintext
 */
declare function decryptAes(encryptedPayload: string | AESEncryptedPayload, key: CryptoKey): Promise<ArrayBuffer>;
declare function decodeAesPayload(payload: string): AESEncryptedPayload;
/**
 * Key derivation using WebCrypto
 * - PBKDF2 with iterations of SHA-256
 * @param {string} password
 * @param {BufferSource} salt
 * @returns {Promise.<CryptoKey>} Promise of CryptoKey object with AES 256-bit symmetric key
 */
declare function deriveAesKey(password: string, salt: Uint8Array, iterationCount?: number): Promise<CryptoKey>;
/**
 * Symmetric key generation
 * - generate an extractable AES 256-bit symmetric key
 * @returns {Promise.<CryptoKey>}
 */
declare function generateKey(extractable?: boolean): Promise<CryptoKey>;
/**
 * Public key pair generation
 * - generate a Curve25519 key pair
 * @returns {Promise.<_sodium.KeyPair>}
 */
declare function generateKeyPair(): Promise<KeyPair>;
/**
 * Encryption using sodium library: https://github.com/jedisct1/libsodium
 * @param {Uint8Array} publicKey public key used to encrypt the data
 * @param {Uint8Array} plaintext raw plaintext byte array
 * @returns {Promise.<string>} Promise of base64 string represents the encrypted payload
 */
declare function encryptWithPublicKey(publicKey: Uint8Array, plaintext: string | Uint8Array): Promise<X25519EncryptedPayload>;
/**
 * Decryption using sodium library: https://github.com/jedisct1/libsodium
 * @param {Uint8Array} privateKey private key used to decrypt the data
 * @param {string} encryptedPayload base64 string represents the encrypted payload
 * @returns {Promise.<Uint8Array>} Promise of raw plaintext byte array
 */
declare function decryptWithPrivateKey(privateKey: Uint8Array, encryptedPayload: X25519EncryptedPayload): Promise<Uint8Array>;
declare function decryptStream(stream: ReadableStream<Uint8Array>, aesKey: CryptoKey, chunkSize: number): Promise<any>;
export { exportKeyToArray, importKeyFromArray, exportKeyToBase64, importKeyFromBase64, importKeyFromSeed, digest, digestRaw, initDigest, chainDigest, signHash, signString, encryptAes, decryptAes, deriveAesKey, generateKey, generateKeyPair, encryptWithPublicKey, decryptWithPrivateKey, decryptStream, decodeAesPayload, };
