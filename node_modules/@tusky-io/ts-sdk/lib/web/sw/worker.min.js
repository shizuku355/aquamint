/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/core/web/worker.js":
/*!********************************!*\
  !*** ./src/core/web/worker.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Service worker intercepting the HTTP requests and decrypting the response stream\n * Usage: \n * 1. Host this file on public route\n * 2. Register the service worker: navigator.serviceWorker.register('worker.js') \n * 3. Post message to worker with the metadata of encrypted file\n * 4. Fire HTTP request to /api/proxy/download/{file-id}\n * \n * Hints:\n * 1. To download decrytped file use:\n      const anchor = document.createElement('a');\n      anchor.href = `/api/proxy/download/${id}`;\n      document.body.appendChild(anchor);\n      anchor.click();\n\n  * 2. To stream video / audio file in browser use:\n      <video>\n          <source src=\"/api/proxy/download/{file-id}?save=false\" type=\"video/mp4\">\n      </video>\n */\n\nif (!self) {\n  __webpack_require__.g.self = __webpack_require__.g;\n  __webpack_require__.g.window = {};\n}\n\nconst DOWNLOAD_URL = /\\/api\\/proxy\\/download\\/(.+)$/;\nconst SYMMETRIC_KEY_ALGORITHM = \"AES-GCM\";\nconst SYMMETRIC_KEY_LENGTH = 256;\nconst AUTH_TAG_SIZE_IN_BYTES = 16;\nconst IV_SIZE_IN_BYTES = 12;\nconst DEFAUTL_CHUNK_SIZE = 5000000 + AUTH_TAG_SIZE_IN_BYTES + IV_SIZE_IN_BYTES; //5MB + encryption bytes\nconst MODE_DECRYPT = \"decrypt\";\n\nconst files = new Map();\n\nself.addEventListener(\"install\", (event) => {\n  event.waitUntil(self.skipWaiting());\n});\n\nself.addEventListener(\"activate\", (event) => {\n  event.waitUntil(self.clients.claim());\n});\n\nself.onmessage = (event) => {\n  if (event.data.type === \"init\") {\n    files.set(event.data.id, { ...event.data, progress: 0 });\n  } else if (event.data.type === \"progress\") {\n    const file = files.get(event.data.id);\n    if (!file) {\n      event.ports[0].postMessage({ error: \"cancelled\" });\n    } else {\n      event.ports[0].postMessage({ type: \"progress\", progress: file.progress });\n    }\n  } else if (event.data.type === \"cancel\") {\n    const file = files.get(event.data.id);\n    if (file) {\n      if (file.cancel) {\n        try {\n          file.cancel.abort(\"client request\");\n        } catch (e) {\n          console.log(e);\n        }\n      }\n      files.delete(event.data.id);\n    }\n  }\n};\n\nself.addEventListener(\"fetch\", (event) => {\n  const req = event.request;\n  if (req.method !== \"GET\") {\n    return;\n  }\n  const url = new URL(req.url);\n  const dlmatch = DOWNLOAD_URL.exec(url.pathname);\n  if (dlmatch) {\n    const range = req.headers.get(\"range\");\n    event.respondWith(decryptStream(dlmatch[1], { range }));\n  }\n});\n\nasync function decryptStream(id, options) {\n  const file = files.get(id);\n  if (!file) {\n    return new Response(null, { status: 400 });\n  }\n  const requsetHeaders = {};\n  if (options.range && file.key) {\n    const internalRange = getChunkedFileRange(options.range, file);\n    if (internalRange) {\n      requsetHeaders[\"Range\"] =\n        `bytes=${internalRange.start}-${internalRange.end}`;\n    }\n  } else {\n    requsetHeaders[\"Range\"] = options.range;\n  }\n\n  const controller = new AbortController();\n  files.set(file.id, { ...file, cancel: controller });\n\n  const response = await fetch(file.url, {\n    headers: requsetHeaders,\n    signal: controller.signal,\n  });\n  const readableStream = response.body;\n  const contentRange = response.headers.get(\"Content-Range\");\n  const externalRange = getExternalRange(contentRange, file);\n  const contentLength = response.headers.get(\"Content-Length\");\n  if (!file.size && !file.chunkSize && contentLength) {\n    file.chunkSize = parseInt(contentLength);\n    files.set(file.id, file);\n  }\n  if (externalRange) {\n    const headers = {\n      \"Accept-Range\": \"bytes\",\n      \"Content-Range\": `bytes ${externalRange.start}-${externalRange.end}/${externalRange.size}`,\n      \"Content-Type\": response.headers.get(\"Content-Type\"),\n      \"Content-Length\": externalRange.end - externalRange.start,\n    };\n    const currentChunkIndex = Math.round(\n      externalRange.start / (file.chunkSize ?? file.size),\n    );\n    return new Response(\n      await getDecryptionStream(file, readableStream, currentChunkIndex),\n      { headers, status: response.status },\n    );\n  } else {\n    const headers = {\n      \"Content-Disposition\": `attachment; filename=\"${encodeURIComponent(file.name)}\"`,\n      \"Content-Type\": \"application/octet-stream\",\n      \"Content-Length\": file.size,\n    };\n    return new Response(await getDecryptionStream(file, readableStream), {\n      headers,\n    });\n  }\n}\n\nasync function getDecryptionStream(file, stream, startChunkIndex = 0) {\n  const chunkSize = file.chunkSize || DEFAUTL_CHUNK_SIZE;\n  const base64Key = file.key;\n  const key = base64Key ? await getDecryptionKey(base64Key) : null;\n  const slicesStream = transformStream(\n    stream,\n    new StreamSlicer(chunkSize, MODE_DECRYPT),\n  );\n  return transformStream(\n    slicesStream,\n    new DecryptStreamController(key, startChunkIndex, file.id, files),\n  );\n}\n\nasync function getDecryptionKey(base64Key) {\n  return await crypto.subtle.importKey(\n    \"raw\",\n    toByteArray(base64Key),\n    {\n      name: SYMMETRIC_KEY_ALGORITHM,\n      length: SYMMETRIC_KEY_LENGTH,\n    },\n    true,\n    [\"encrypt\", \"decrypt\"],\n  );\n}\n\nasync function getCleartext(key, ivBytes, bytes) {\n  try {\n    return await crypto.subtle.decrypt(\n      {\n        name: \"AES-GCM\",\n        iv: ivBytes,\n      },\n      key,\n      bytes,\n    );\n  } catch (e) {\n    console.log(e);\n  }\n}\n\nfunction toByteArray(b64) {\n  return Uint8Array.from(atob(b64), (c) => c.charCodeAt(0));\n}\n\nfunction getExternalRange(range, file) {\n  if (!range) {\n    return null;\n  }\n  const byteRangeWithTotalSize = range.split(\" \")[1];\n  const byteRange = byteRangeWithTotalSize.split(\"/\")[0];\n  const byteStartEnd = byteRange.split(\"-\");\n  const byteStart = parseInt(byteStartEnd[0]);\n  const byteEnd = byteStartEnd[1] ? parseInt(byteStartEnd[1]) : null;\n  if (!file.key) {\n    return { start: byteStart, end: byteEnd, size: file.size };\n  }\n\n  const chunkSize = file.chunkSize ?? DEFAUTL_CHUNK_SIZE;\n\n  let unencryptedFileSize;\n  if (file.numberOfChunks && file.numberOfChunks > 0) {\n    unencryptedFileSize =\n      file.size -\n      file.numberOfChunks * (AUTH_TAG_SIZE_IN_BYTES + IV_SIZE_IN_BYTES);\n  } else {\n    const numberOfChunks = Math.ceil(file.size / chunkSize);\n    unencryptedFileSize =\n      file.size - numberOfChunks * (AUTH_TAG_SIZE_IN_BYTES + IV_SIZE_IN_BYTES);\n  }\n  const start =\n    byteStart -\n    Math.floor(byteStart / chunkSize) *\n      (AUTH_TAG_SIZE_IN_BYTES + IV_SIZE_IN_BYTES);\n  const end = byteEnd\n    ? byteEnd -\n      Math.ceil(byteEnd / chunkSize) *\n        (AUTH_TAG_SIZE_IN_BYTES + IV_SIZE_IN_BYTES)\n    : \"\";\n  return { start, end, size: unencryptedFileSize };\n}\n\nfunction getChunkedFileRange(range, file) {\n  if (!range || !range.includes(\"=\") || !range.includes(\"-\")) {\n    return null;\n  }\n  const byteRange = range.split(\"=\")[1];\n  const byteStartEnd = byteRange.split(\"-\");\n  const byteStart = parseInt(byteStartEnd[0]);\n  const byteEnd = byteStartEnd[1] ? parseInt(byteStartEnd[1]) : null;\n  let requestRangeStart;\n  let requestRangeEnd;\n  let currnentByte = 0;\n  requestRangeStart = currnentByte;\n  while (currnentByte < file.size) {\n    if (currnentByte <= byteStart) {\n      requestRangeStart = currnentByte;\n    } else {\n      break;\n    }\n    currnentByte += file.chunkSize ?? file.size;\n  }\n  if (!byteEnd) {\n    requestRangeEnd = \"\";\n  } else {\n    currnentByte = requestRangeStart;\n    while (currnentByte < file.size) {\n      if (byteEnd <= currnentByte) {\n        requestRangeEnd = currnentByte;\n      } else {\n        break;\n      }\n      currnentByte += file.chunkSize ?? file.size;\n    }\n  }\n  return { start: requestRangeStart, end: requestRangeEnd };\n}\n\nclass DecryptStreamController {\n  constructor(key, index, id, files) {\n    this.key = key;\n    this.index = index || 0;\n    if (id) {\n      this.file = files.get(id);\n    }\n  }\n\n  async transform(chunk, controller) {\n    let ivBytes;\n    let ciphertextBytes;\n    if (this.key) {\n      ivBytes = chunk.slice(0, IV_SIZE_IN_BYTES);\n      ciphertextBytes = chunk.slice(IV_SIZE_IN_BYTES);\n    }\n    try {\n      const cleartext = this.key\n        ? await getCleartext(this.key, ivBytes, ciphertextBytes)\n        : chunk;\n      controller.enqueue(new Uint8Array(cleartext));\n      if (this.file) {\n        this.file.progress +=\n          cleartext.byteLength + AUTH_TAG_SIZE_IN_BYTES + IV_SIZE_IN_BYTES;\n        files.set(this.file.id, this.file);\n      }\n      this.index += 1;\n    } catch (e) {\n      console.log(e);\n    }\n  }\n}\n\nclass StreamSlicer {\n  constructor(rs, mode) {\n    this.mode = mode;\n    this.rs = rs;\n    this.chunkSize = rs;\n    this.partialChunk = new Uint8Array(this.chunkSize);\n    this.offset = 0;\n  }\n\n  send(buf, controller) {\n    controller.enqueue(buf);\n    if (this.chunkSize === 21 && this.mode === MODE_DECRYPT) {\n      this.chunkSize = this.rs;\n    }\n    this.partialChunk = new Uint8Array(this.chunkSize);\n    this.offset = 0;\n  }\n\n  //reslice input into record sized chunks\n  transform(chunk, controller) {\n    let i = 0;\n\n    if (this.offset > 0) {\n      const len = Math.min(chunk.byteLength, this.chunkSize - this.offset);\n      this.partialChunk.set(chunk.slice(0, len), this.offset);\n      this.offset += len;\n      i += len;\n\n      if (this.offset === this.chunkSize) {\n        this.send(this.partialChunk, controller);\n      }\n    }\n\n    while (i < chunk.byteLength) {\n      const remainingBytes = chunk.byteLength - i;\n      if (remainingBytes >= this.chunkSize) {\n        const record = chunk.slice(i, i + this.chunkSize);\n        i += this.chunkSize;\n        this.send(record, controller);\n      } else {\n        const end = chunk.slice(i, i + remainingBytes);\n        i += end.byteLength;\n        this.partialChunk.set(end);\n        this.offset = end.byteLength;\n      }\n    }\n  }\n\n  flush(controller) {\n    if (this.offset > 0) {\n      controller.enqueue(this.partialChunk.slice(0, this.offset));\n    }\n  }\n}\n\nfunction transformStream(readable, transformer, oncancel) {\n  try {\n    return readable.pipeThrough(new TransformStream(transformer));\n  } catch (e) {\n    const reader = readable.getReader();\n    return new ReadableStream({\n      start(controller) {\n        if (transformer.start) {\n          return transformer.start(controller);\n        }\n      },\n      async pull(controller) {\n        let enqueued = false;\n        const wrappedController = {\n          enqueue(d) {\n            enqueued = true;\n            controller.enqueue(d);\n          },\n        };\n        while (!enqueued) {\n          const data = await reader.read();\n          if (data.done) {\n            if (transformer.flush) {\n              await transformer.flush(controller);\n            }\n            return controller.close();\n          }\n          await transformer.transform(data.value, wrappedController);\n        }\n      },\n      cancel(reason) {\n        readable.cancel(reason);\n        if (oncancel) {\n          oncancel(reason);\n        }\n      },\n    });\n  }\n}\n\n\n//# sourceURL=webpack://@tusky-io/ts-sdk/./src/core/web/worker.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/core/web/worker.js"](0, __webpack_exports__, __webpack_require__);
/******/ 	
/******/ })()
;