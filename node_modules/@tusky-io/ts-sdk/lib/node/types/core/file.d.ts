import { FileSource } from "../types/node/file";
import { ApiClient } from "../api/api-client";
import { File, FileDownloadOptions, FileUploadOptions } from "../types";
import { GetOptions, ListOptions } from "../types/query-options";
import { Paginated } from "../types/paginated";
import { ReadableStream } from "web-streams-polyfill/ponyfill/es2018";
import { FileService } from "./service/file";
import { ServiceConfig } from "./service/service";
import * as tus from "tus-js-client";
import { Auth } from "../auth";
import { Subscription } from "rxjs";
export declare const DEFAULT_FILE_TYPE = "text/plain";
export declare const DEFAULT_FILE_NAME = "unnamed";
export declare const BYTES_IN_MB = 1000000;
export declare const CHUNK_SIZE_IN_BYTES: number;
export declare const ENCRYPTED_CHUNK_SIZE_IN_BYTES: number;
export declare const UPLOADER_SERVER_MAX_CONNECTIONS_PER_CLIENT = 20;
export declare const EMPTY_FILE_ERROR_MESSAGE = "Cannot upload an empty file";
export declare const UPLOAD_COOKIE_SESSION_NAME = "tusky.upload.session.id";
declare class FileModule {
    protected contentType: string;
    protected client: ApiClient;
    protected type: "File";
    protected service: FileService;
    protected parentId?: string;
    protected defaultListOptions: ListOptions;
    protected defaultGetOptions: GetOptions;
    protected defaultCreateOptions: {
        parentId: any;
    };
    protected auth: Auth;
    protected folderIdMap: Record<string, string>;
    constructor(config?: ServiceConfig);
    /**
     * Generate preconfigured Tus uploader
     * @param  {string} vaultId
     * @param  {FileSource} file
     *    Nodejs: Buffer | Readable | string (path) | ArrayBuffer | Uint8Array
     *    Browser: File | Blob | Uint8Array | ArrayBuffer
     * @param  {FileUploadOptions} options parent id, file name file mime type, etc
     * @returns {Promise<Promise<tus.Upload>>} Promise with tus.Upload instance
     *
     * @example
     * // use in Browser with Uppy upload
     *
     * const uploader = tusky.zip.uploader(vaultId);
     *
     * const uppy = new Uppy({
     *    restrictions: {
     *      allowedFileTypes: ['.zip', 'application/zip', 'application/x-zip-compressed'],
     *      maxFileSize: 1000000000,
     *    },
     *    autoProceed: false
     *  })
     *  .use(Tus, uploader.options);
     *
     * uppy.addFile(file);
     * uppy.upload();
     *
     * @example
     * // use in Nodejs
     *
     * const uploader = tusky.zip.uploader(vaultId, file, {
     *    onSuccess: () => {
     *      console.log('Upload complete');
     *    },
     *    onError: (error) => {
     *      console.log('Upload error', error);
     *    },
     *    onProgress: (progress) => {
     *      console.log('Upload progress', progress);
     *    }
     * });
     *
     * uploader.start();
     *
     */
    uploader(vaultId: string, file?: FileSource | any, options?: FileUploadOptions): Promise<tus.Upload>;
    /**
     * Upload file
     * @param  {string} vaultId
     * @param  {FileSource} file
     *    Nodejs: Buffer | Readable | string (path) | ArrayBuffer | Uint8Array
     *    Browser: File | Blob | Uint8Array | ArrayBuffer
     * @param  {FileUploadOptions} options parent id, file name file mime type, etc.
     * @returns {Promise<string>} Promise with upload id
     */
    upload(vaultId: string, file: FileSource, options?: FileUploadOptions): Promise<string>;
    /**
     * @param {string} id
     * @returns {Promise<File>}
     */
    get(id: string, options?: GetOptions): Promise<File>;
    /**
     * @param  {ListOptions} options
     * @returns {Promise<Paginated<File>>} Promise with paginated user files
     */
    list(options?: ListOptions): Promise<Paginated<File>>;
    /**
     * @param  {ListOptions} options
     * @returns {Promise<Array<File>>} Promise with all user files
     */
    listAll(options?: ListOptions): Promise<Array<File>>;
    /**
     * @param  {string} id file id
     * @param  {string} name new name
     * @returns {Promise<File>}
     */
    rename(id: string, name: string): Promise<File>;
    /**
     * @param  {string} id
     * @param  {string} [parentId] new parent folder id, if no parent id provided will be moved to the vault root.
     * @returns {Promise<File>}
     */
    move(id: string, parentId?: string): Promise<File>;
    /**
     * The file will be moved to the trash. The file will be permanently deleted within 30 days.
     * To undo this action, call file.restore() within the 30-day period.
     * @param  {string} id file id
     * @returns {Promise<File>}
     */
    delete(id: string): Promise<File>;
    /**
     * Restores the file from the trash.
     * This action must be performed within 30 days of the file being moved to the trash to prevent permanent deletion.
     * @param  {string} id file id
     * @returns {Promise<File>}
     */
    restore(id: string): Promise<File>;
    /**
     * The file will be permanently deleted.
     * This action is irrevocable and can only be performed if the file is already in trash.
     * @param  {string} id file id
     * @returns {Promise<void>}
     */
    deletePermanently(id: string): Promise<void>;
    stream(id: string): Promise<ReadableStream<Uint8Array>>;
    arrayBuffer(id: string): Promise<ArrayBuffer>;
    /**
     * Subscribe to file create/update events.
     * @param  {string} vaultId
     * @param  {(file: File) => Promise<void>} onSuccess
     * @param  {(error: Error) => void} onError
     * @returns {Subscription}
     * @example
     * // To unsubscribe:
     * const subscription = await tusky.file.subscribe(vaultId, onSuccess, onError);
     * subscription.unsubscribe();
     */
    subscribe(vaultId: string, onSuccess: (file: File) => Promise<void>, onError: (error: Error) => void): Promise<Subscription>;
    protected aesKey(id: string): Promise<CryptoKey | null>;
}
export type FileUploadResult = {
    resourceUri: string[];
    resourceHash?: string;
    numberOfChunks?: number;
    chunkSize?: number;
    iv?: string[];
    encryptedKey?: string;
};
export type Hooks = {
    onProgress?: ((bytesSent: number, bytesTotal: number) => void) | null;
    onChunkComplete?: ((chunkSize: number, bytesAccepted: number, bytesTotal: number) => void) | null;
    onSuccess?: (() => void) | null;
    onError?: ((error: Error | tus.DetailedError) => void) | null;
};
export type FileMetadataOptions = {
    name?: string;
    mimeType?: string;
    lastModified?: number;
};
export type FileLocationOptions = {
    parentId?: string;
};
export type FileGetOptions = FileDownloadOptions & {
    responseType?: "arraybuffer" | "stream";
};
export declare const onUpdateFile = "subscription OnUpdateFile($filter: ModelSubscriptionFileFilterInput) {\n  onUpdateFile(filter: $filter) {\n    id\n    owner\n    vaultId\n    parentId\n    uploadId\n    partition\n    name\n    size\n    status\n    chunkSize\n    numberOfChunks\n    storedEpoch\n    blobId\n    ref\n    erasureCodeType\n    certifiedEpoch\n    mimeType\n    encryptedAesKey\n    expiresAt\n    createdAt\n    updatedAt\n    __typename\n  }\n}\n";
export { FileModule };
