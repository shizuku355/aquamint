import { Membership } from "../types/membership";
import { Paginated } from "../types/paginated";
import { Vault } from "../types/vault";
import { Auth } from "../auth";
import { User } from "../types/user";
import { AllowedPaths, EncryptedVaultKeyPair, File, Folder } from "../types";
import { Storage } from "../types/storage";
import { ApiKey } from "../types/api-key";
import { GenerateJWTResponsePayload } from "../types/auth";
import { Collection } from "../types/collection";
import { NFT } from "../types/nft";
export declare class ApiClient {
    private _apiUrl;
    private _cdnUrl;
    private _auth;
    private _meUri;
    private _keysUri;
    private _vaultUri;
    private _fileUri;
    private _folderUri;
    private _trashUri;
    private _membershipUri;
    private _apiKeyUri;
    private _storageUri;
    private _subscriptionUri;
    private _collectionUri;
    private _nftUri;
    private _resourceId;
    private _name;
    private _status;
    private _vaultId;
    private _parentId;
    private _authProvider;
    private _redirectUri;
    private _refreshToken;
    private _authCode;
    private _grantType;
    private _encrypted;
    private _description;
    private _tags;
    private _keys;
    private _address;
    private _role;
    private _expiresAt;
    private _allowedStorage;
    private _allowedPaths;
    private _ownerAccess;
    private _numberOfChunks;
    private _picture;
    private _trashExpiration;
    private _publicKey;
    private _encPrivateKey;
    private _encPrivateKeyBackup;
    private _recipient;
    private _thumbnailUrl;
    private _projectUrl;
    private _creator;
    private _link;
    private _signature;
    private _digest;
    private _sdkVersion;
    private _clientName;
    private _groupId;
    private _httpClient;
    private _data;
    private _queryParams;
    private _progressId;
    private _progressHook;
    private _cancelHook;
    private _publicRoute;
    private _totalBytes;
    private _uploadedBytes;
    constructor();
    clone(): ApiClient;
    env(config: {
        apiUrl: string;
        cdnUrl: string;
    }): ApiClient;
    auth(auth: Auth): ApiClient;
    resourceId(resourceId: string): ApiClient;
    status(status: string): ApiClient;
    encrypted(encrypted: boolean): ApiClient;
    publicRoute(publicRoute: boolean): ApiClient;
    keys(keys: Array<EncryptedVaultKeyPair>): ApiClient;
    description(description: string): ApiClient;
    recipient(recipient: string): ApiClient;
    thumbnailUrl(thumbnailUrl: string): ApiClient;
    projectUrl(projectUrl: string): ApiClient;
    creator(creator: string): ApiClient;
    link(link: string): ApiClient;
    tags(tags: string[]): ApiClient;
    vaultId(vaultId: string): ApiClient;
    clientName(clientName: string): ApiClient;
    groupId(groupId: string): ApiClient;
    signature(signature: string): ApiClient;
    parentId(parentId: any): ApiClient;
    name(name: string): ApiClient;
    role(role: string): ApiClient;
    expiresAt(expiresAt: number): ApiClient;
    allowedStorage(allowedStorage: number): ApiClient;
    allowedPaths(allowedPaths: AllowedPaths): ApiClient;
    picture(picture: string): ApiClient;
    trashExpiration(trashExpiration: number): ApiClient;
    publicKey(publicKey: string): ApiClient;
    encPrivateKey(encPrivateKey: string): ApiClient;
    encPrivateKeyBackup(encPrivateKeyBackup: string): ApiClient;
    ownerAccess(ownerAccess: string): ApiClient;
    authProvider(authProvider: string): ApiClient;
    redirectUri(redirectUri: string): ApiClient;
    refreshToken(refreshToken: string): ApiClient;
    authCode(authCode: string): ApiClient;
    grantType(grantType: string): ApiClient;
    address(address: string): ApiClient;
    digest(digest: string): ApiClient;
    data(data: any): ApiClient;
    queryParams(queryParams: any): ApiClient;
    totalBytes(totalBytes: number): ApiClient;
    loadedBytes(uploadedBytes: number): ApiClient;
    progressHook(hook: (percentageProgress: number, bytesProgress?: number, id?: string) => void, id?: string): ApiClient;
    cancelHook(hook: AbortController): ApiClient;
    numberOfChunks(numberOfChunks: number): ApiClient;
    /**
     * Fetch currently authenticated user
     * @returns {Promise<User>}
     */
    getMe(): Promise<User>;
    /**
     * Update currently authenticated user
     * @uses:
     * - name()
     * - picture()
     * - encPrivateKey()
     * - encPrivateKeyBackup()
     * @returns {Promise<User>}
     */
    updateMe(): Promise<User>;
    /**
     * Create user encryption keys backup
     * @uses:
     * - publicKey()
     * - encPrivateKey()
     * - encPrivateKeyBackup()
     * @returns {Promise<User>}
     */
    createEncryptionKeys(): Promise<User>;
    /**
     * Update currently authenticated user encryption keys backup
     * @uses:
     * - publicKey()
     * - encPrivateKey()
     * - encPrivateKeyBackup()
     * @returns {Promise<User>}
     */
    updateEncryptionKeys(): Promise<User>;
    /**
     * Deletes currently authenticated user encryption keys
     * @returns {Promise<void>}
     */
    deleteEncryptionKeys(): Promise<void>;
    /**
     *
     * @uses:
     * - vaultId()
     * @returns {Promise<Paginated<Membership>>}
     */
    getMembers(): Promise<Paginated<Membership>>;
    /**
     * Get memberships for currently authenticated user
     * @uses:
     * - queryParams() - limit, nextToken
     * @returns {Promise<Paginated<Membership>>}
     */
    getMemberships(): Promise<Paginated<Membership>>;
    /**
     * Get vaults for currently authenticated user
     * @uses:
     * - queryParams() - status, limit, nextToken
     * @returns {Promise<Paginated<Vault>>}
     */
    getVaults(): Promise<Paginated<Vault>>;
    /**
     * Get files for currently authenticated user
     * @uses:
     * - queryParams() - vaultId, parentId, status, limit, nextToken
     * @returns {Promise<Paginated<File>>}
     */
    getFiles(): Promise<Paginated<File>>;
    /**
     * Get folders for currently authenticated user
     * @uses:
     * - queryParams() - status, vaultId, parentId, limit, nextToken
     * @returns {Promise<Paginated<Folder>>}
     */
    getFolders(): Promise<Paginated<Folder>>;
    /**
     * Get memberships by vault id
     * @uses:
     * - vaultId()
     * - queryParams() - status, limit, nextToken
     * @returns {Promise<Paginated<Membership>>}
     */
    getMembershipsByVaultId(): Promise<Paginated<Membership>>;
    /**
     * Get file by id
     * @uses:
     * - resourceId()
     * @returns {Promise<File>}
     */
    getFile(): Promise<File>;
    /**
     * Get folder by id
     * @uses:
     * - resourceId()
     * @returns {Promise<Folder>}
     */
    getFolder(): Promise<Folder>;
    /**
     * Get membership by id
     * @uses:
     * - resourceId()
     * @returns {Promise<Membership>}
     */
    getMembership(): Promise<Membership>;
    /**
     * Get vault by id
     * @uses:
     * - resourceId()
     * - queryParams() - withNodes, withMemberships, withMemos, withStacks, withFolders
     * @returns {Promise<Vault>}
     */
    getVault(): Promise<Vault>;
    /**
     * Get user api keys
     * @returns {Promise<Paginated<ApiKey>>}
     */
    getApiKeys(): Promise<Paginated<ApiKey>>;
    /**
     * Generate new api key
     * @uses:
     * - resourceId()
     * @returns {Promise<ApiKey>}
     */
    generateApiKey(): Promise<ApiKey>;
    /**
     * Revoke an existing api key
     * @uses:
     * - resourceId()
     * @returns {Promise<ApiKey>}
     */
    revokeApiKey(): Promise<ApiKey>;
    /**
     * Get nft collections for currently authenticated user
     * @uses:
     * - queryParams() - limit, nextToken
     * @returns {Promise<Paginated<Collection>>}
     */
    getCollections(): Promise<Paginated<Collection>>;
    /**
     * Get nfts for currently authenticated user
     * @uses:
     * - queryParams() - status, limit, nextToken
     * @returns {Promise<Paginated<NFT>>}
     */
    getNfts(): Promise<Paginated<NFT>>;
    /**
     * Get nft by id
     * @uses:
     * - resourceId()
     * @returns {Promise<NFT>}
     */
    getNft(): Promise<NFT>;
    /**
     * Get collection by id
     * @uses:
     * - resourceId()
     * @returns {Promise<Collection>}
     */
    getCollection(): Promise<Collection>;
    /**
     *
     * @requires:
     * - name()
     * @uses:
     * - description()
     * @returns {Promise<NFT>}
     */
    mintNft(): Promise<NFT>;
    /**
     *
     * @requires:
     * @uses:
     * - description()
     * @returns {Promise<NFT>}
     */
    mintCollection(): Promise<Collection>;
    post(url: string): Promise<any>;
    put(url: string): Promise<any>;
    patch(url: string): Promise<any>;
    get(url: string): Promise<any>;
    delete(url: string): Promise<any>;
    fetch(method: string, url: string): Promise<any>;
    addQueryParams: (url: string, params: any) => string;
    /**
     *
     * @requires:
     * - resourceId()
     * @uses:
     * - name()
     * - parentId()
     * - status()
     * @returns {Promise<File>}
     */
    updateFile(): Promise<File>;
    /**
     *
     * @requires:
     * - resourceId()
     * @returns {Promise<void>}
     */
    deleteFile(): Promise<void>;
    /**
     *
     * @requires:
     * - vaultId()
     * - name()
     * @uses:
     * - parentId()
     * @returns {Promise<Folder>}
     */
    createFolder(): Promise<Folder>;
    /**
     *
     * @requires:
     * - vaultId()
     * @uses:
     * - parentId()
     * @returns {Promise<Folder>}
     */
    createFolderTree(): Promise<{
        folderIdMap: Record<string, string>;
    }>;
    /**
     *
     * @requires:
     * - address()
     * @returns {Promise<string>}
     */
    createAuthChallenge(): Promise<{
        nonce: string;
    }>;
    /**
     *
     * @requires:
     * - address()
     * - signature()
     * @returns {Promise<string>}
     */
    verifyAuthChallenge(): Promise<GenerateJWTResponsePayload>;
    /**
     *
     * @requires:
     * - authProvider()
     * - grantType()
     * @uses:
     * - redirectUri()
     * - code()
     * - refreshToken()
     * @returns {Promise<string>}
     */
    generateJWT(): Promise<GenerateJWTResponsePayload>;
    /**
     *
     * @requires:
     * - resourceId()
     * @uses:
     * - name()
     * - parentId()
     * - status()
     * @returns {Promise<Folder>}
     */
    updateFolder(): Promise<Folder>;
    /**
     *
     * @requires:
     * - resourceId()
     * @returns {Promise<void>}
     */
    deleteFolder(): Promise<void>;
    /**
     *
     * @requires:
     * - name()
     * @uses:
     * - description()
     * - encrypted()
     * - tags()
     * - keys()
     * @returns {Promise<Vault>}
     */
    createVault(): Promise<Vault>;
    /**
     *
     * @requires:
     * - resourceId()
     * @uses:
     * - name()
     * - description()
     * - status()
     * @returns {Promise<Vault>}
     */
    updateVault(): Promise<Vault>;
    /**
     *
     * @requires:
     * - resourceId()
     * @returns {Promise<void>}
     */
    deleteVault(): Promise<void>;
    getTrash(): Promise<Folder>;
    emptyTrash(): Promise<Folder>;
    /**
     *
     * @requires:
     * - vaultId()
     * - address()
     * - role()
     * @uses:
     * - expiresAt()
     * - keys()
     * - encPrivateKey()
     * - allowedStorage()
     * - allowedPaths()
     * @returns {Promise<Membership>}
     */
    createMembership(): Promise<Membership>;
    /**
     *
     * @requires:
     * - resourceId()
     * @uses:
     * - role()
     * - expiresAt()
     * - status()
     * - keys()
     * @returns {Promise<Membership>}
     */
    updateMembership(): Promise<Membership>;
    /**
     *
     * @requires:
     * - resourceId()
     * @uses:
     * - keys()
     * @returns {Promise<void>}
     */
    deleteMembership(): Promise<void>;
    /**
     *
     * @requires:
     * - resourceId()
     * @uses:
     * - responseType()
     * - encrypted()
     * - progressHook()
     * - cancelHook()
     * - numberOfChunks()
     */
    downloadFile(): Promise<Response>;
    getStorage(): Promise<Storage>;
    private getCustomHeaders;
}
export declare function retry<T>(fn: () => Promise<T>, force?: boolean, retries?: number, delayMs?: number): Promise<T>;
